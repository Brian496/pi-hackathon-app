#!/usr/bin/env python3
import argparse
import json
import os
import sys
import time
from typing import Dict, List, Optional, Set, Tuple

import requests


MEMPOOL_API = "https://mempool.space/api"


def http_get_json(path: str) -> Optional[dict]:
    url = f"{MEMPOOL_API}{path}"
    try:
        resp = requests.get(url, timeout=20)
        if resp.status_code != 200:
            return None
        return resp.json()
    except Exception:
        return None


def fetch_tx(txid: str) -> Optional[dict]:
    return http_get_json(f"/tx/{txid}")


def fetch_outspends(txid: str) -> Optional[List[dict]]:
    data = http_get_json(f"/tx/{txid}/outspends")
    if isinstance(data, list):
        return data
    return None


def detect_coinjoin(tx: dict) -> bool:
    try:
        vins = tx.get("vin", [])
        vouts = tx.get("vout", [])
        if len(vins) >= 5 and len(vouts) >= 5:
            values = [int((o.get("value") or 0)) for o in vouts]
            # Count how many outputs share the same value (heuristic for CoinJoin)
            counts: Dict[int, int] = {}
            for v in values:
                counts[v] = counts.get(v, 0) + 1
            if any(c >= 3 for c in counts.values()):
                return True
        return False
    except Exception:
        return False


def summarize_outputs(tx: dict) -> List[Tuple[str, int]]:
    summary: List[Tuple[str, int]] = []
    for o in tx.get("vout", []):
        # mempool.space returns scripts with addresses under scriptpubkey_address
        addr = o.get("scriptpubkey_address") or "(unknown)"
        val = int(o.get("value") or 0)
        summary.append((addr, val))
    return summary


def load_iocs(path: str) -> Tuple[Optional[str], List[str]]:
    with open(path, "r") as f:
        data = json.load(f)
    txid = data.get("primary_txid")
    addrs = data.get("addresses") or []
    return txid, addrs


def trace_peel_chain(start_txid: str, max_hops: int) -> List[Tuple[int, str]]:
    """
    Returns list of (hop, txid) for each successive spending tx discovered from the
    outputs of the previous tx. If multiple outputs are spent, we follow all (breadth-first)
    up to max_hops depth, but we record first-order chain preference by order discovered.
    """
    queue: List[Tuple[int, str]] = [(0, start_txid)]
    visited: Set[str] = set()
    chain: List[Tuple[int, str]] = []

    while queue:
        hop, txid = queue.pop(0)
        if txid in visited:
            continue
        visited.add(txid)
        chain.append((hop, txid))
        if hop >= max_hops:
            continue

        outspends = fetch_outspends(txid)
        if not outspends:
            continue
        # For each spent output, enqueue the spending txid
        next_txids: List[str] = []
        for os in outspends:
            if os and os.get("spent") and os.get("txid"):
                next_txids.append(os["txid"]) 
        # Prefer deterministic order
        for nxt in sorted(set(next_txids)):
            queue.append((hop + 1, nxt))

    return chain


def log_entry(msg: str, log_file: Optional[str]):
    line = time.strftime("%Y-%m-%d %H:%M:%S ") + msg
    print(line, flush=True)
    if log_file:
        try:
            with open(log_file, "a") as f:
                f.write(line + "\n")
        except Exception:
            pass


def send_slack_message(webhook_url: Optional[str], text: str) -> bool:
    if not webhook_url:
        return False
    try:
        resp = requests.post(webhook_url, json={"text": text}, timeout=15)
        return resp.status_code in (200, 204)
    except Exception:
        return False


def send_telegram_message(bot_token: Optional[str], chat_id: Optional[str], text: str) -> bool:
    if not bot_token or not chat_id:
        return False
    try:
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        resp = requests.post(url, json={"chat_id": chat_id, "text": text, "disable_web_page_preview": True}, timeout=15)
        return resp.status_code == 200
    except Exception:
        return False


def send_generic_webhook(webhook_url: Optional[str], payload: Dict) -> bool:
    if not webhook_url:
        return False
    try:
        resp = requests.post(webhook_url, json=payload, timeout=15)
        return 200 <= resp.status_code < 300
    except Exception:
        return False


def format_alert(hop: int, txid: str, coinjoin: bool, outs: List[Tuple[str, int]], total_out: int) -> str:
    preview = ", ".join([f"{addr}:{val}" for addr, val in outs[:5]])
    return (
        f"BTC tracker: hop={hop} txid={txid} coinjoin={coinjoin} "
        f"outputs={len(outs)} total_sats={total_out} preview=[{preview}]"
    )


def main():
    parser = argparse.ArgumentParser(description="BTC peel-chain tracker with CoinJoin detection (mempool.space)")
    parser.add_argument("--iocs", required=True, help="Path to IOC JSON with primary_txid and addresses")
    parser.add_argument("--max-hops", type=int, default=5, help="Maximum peel-chain hops to follow")
    parser.add_argument("--interval", type=int, default=300, help="Polling interval seconds between rechecks")
    parser.add_argument("--log", default=None, help="Optional log file path")
    # Alerting
    parser.add_argument("--slack-webhook", default=None, help="Slack webhook URL (or SLACK_WEBHOOK_URL env)")
    parser.add_argument("--telegram-bot-token", default=None, help="Telegram bot token (or TELEGRAM_BOT_TOKEN env)")
    parser.add_argument("--telegram-chat-id", default=None, help="Telegram chat ID (or TELEGRAM_CHAT_ID env)")
    parser.add_argument("--alert-webhook", default=None, help="Generic webhook URL (or ALERT_WEBHOOK_URL env)")
    parser.add_argument(
        "--alert-on",
        default="hop,coinjoin,error",
        help="Comma list of events to alert on: hop,coinjoin,error",
    )
    # Thresholds and routing tags
    parser.add_argument("--high-sev-threshold-sats", type=int, default=1000000000, help="Escalate if total outs >= this (default 10 BTC)")
    parser.add_argument("--route-triage", default="#onchain-triage", help="Slack/route tag for triage feed")
    parser.add_argument("--route-incidents", default="#onchain-incidents", help="Slack/route tag for incidents feed")
    parser.add_argument("--route-exec", default="#exec-brief", help="Slack/route tag for exec brief")
    args = parser.parse_args()

    try:
        primary_txid, addresses = load_iocs(args.iocs)
    except Exception as e:
        print(f"Failed to load IOCs: {e}")
        sys.exit(1)

    if not primary_txid:
        print("No primary_txid in IOC file")
        sys.exit(1)

    # Resolve alert settings (CLI takes precedence over env)
    slack_webhook = args.slack_webhook or os.getenv("SLACK_WEBHOOK_URL")
    tg_token = args.telegram_bot_token or os.getenv("TELEGRAM_BOT_TOKEN")
    tg_chat = args.telegram_chat_id or os.getenv("TELEGRAM_CHAT_ID")
    generic_webhook = args.alert_webhook or os.getenv("ALERT_WEBHOOK_URL")
    alert_on: Set[str] = set([x.strip() for x in str(args.alert_on).split(",") if x.strip()])

    alert_channels: List[str] = []
    if slack_webhook:
        alert_channels.append("slack")
    if tg_token and tg_chat:
        alert_channels.append("telegram")
    if generic_webhook:
        alert_channels.append("webhook")

    log_entry(
        f"Starting BTC tracker. Primary txid={primary_txid}, addresses={addresses} alerts={alert_channels} alert_on={sorted(list(alert_on))}",
        args.log,
    )

    seen: Set[str] = set()

    while True:
        try:
            chain = trace_peel_chain(primary_txid, args.max_hops)
            for hop, txid in chain:
                if txid in seen:
                    continue
                tx = fetch_tx(txid) or {}
                coinjoin = detect_coinjoin(tx)
                outs = summarize_outputs(tx)
                total_out = sum(v for _, v in outs)
                out_preview = ", ".join([f"{addr}:{val}" for addr, val in outs[:5]])
                log_entry(
                    f"hop={hop} txid={txid} coinjoin={coinjoin} outputs={len(outs)} total_sats={total_out} preview=[{out_preview}]",
                    args.log,
                )
                # Alerts for hop and coinjoin
                try:
                    alert_text = format_alert(hop, txid, coinjoin, outs, total_out)
                    route = args.route_triage
                    if total_out >= args.high_sev_threshold_sats or coinjoin:
                        route = args.route_incidents
                    if "hop" in alert_on:
                        _ = send_slack_message(slack_webhook, f"[{route}] {alert_text}")
                        _ = send_telegram_message(tg_token, tg_chat, f"[{route}] {alert_text}")
                        _ = send_generic_webhook(generic_webhook, {
                            "event": "hop",
                            "hop": hop,
                            "txid": txid,
                            "coinjoin": coinjoin,
                            "outputs": outs,
                            "total_sats": total_out,
                            "route": route,
                        })
                    if coinjoin and ("coinjoin" in alert_on):
                        cj_route = args.route_incidents
                        cj_text = f"[{cj_route}] [CoinJoin suspected] {alert_text}"
                        _ = send_slack_message(slack_webhook, cj_text)
                        _ = send_telegram_message(tg_token, tg_chat, cj_text)
                        _ = send_generic_webhook(generic_webhook, {
                            "event": "coinjoin",
                            "hop": hop,
                            "txid": txid,
                            "outputs": outs,
                            "total_sats": total_out,
                            "route": cj_route,
                        })
                except Exception:
                    pass
                seen.add(txid)
        except Exception as e:
            log_entry(f"Error during tracking: {e}", args.log)
            # Alert on error
            try:
                if "error" in alert_on:
                    err_text = f"[{args.route_triage}] BTC tracker error: {e}"
                    _ = send_slack_message(slack_webhook, err_text)
                    _ = send_telegram_message(tg_token, tg_chat, err_text)
                    _ = send_generic_webhook(generic_webhook, {"event": "error", "message": str(e), "route": args.route_triage})
            except Exception:
                pass

        time.sleep(args.interval)


if __name__ == "__main__":
    main()



