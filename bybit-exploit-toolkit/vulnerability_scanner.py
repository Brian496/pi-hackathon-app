#!/usr/bin/env python3
"""
Bybit-Style Vulnerability Scanner
Automated detection of delegatecall exploits, upgrade mechanisms, and multisig vulnerabilities
"""

import json
import argparse
import time
import asyncio
import requests
from web3 import Web3
from eth_abi import decode
from typing import Dict, List, Any, Optional
import os
from dataclasses import dataclass

# Load environment configuration  
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    print("Warning: python-dotenv not installed. Using environment variables directly.")

@dataclass
class Vulnerability:
    """Vulnerability data structure"""
    severity: str
    type: str
    contract: str
    description: str
    details: Dict[str, Any]

class VulnerabilityScanner:
    """Main vulnerability scanner class"""
    
    def __init__(self, rpc_url: str = None, targets: Optional[Dict[str, str]] = None):
        # Use environment variable if no RPC URL provided
        if rpc_url is None:
            # Prefer SONIC if present, else ETH
            rpc_url = os.getenv('SONIC_RPC_URL') or os.getenv('ETH_RPC_URL', 'https://eth-mainnet.alchemyapi.io/v2/demo')
        self.web3 = Web3(Web3.HTTPProvider(rpc_url))
        self.rpc_url = rpc_url
        
        # High-value target contracts
        default_targets = {
            "Compound COMP": "0xc00e94Cb662C3520282E6f5717214004A7f26888",
            "Aave AAVE": "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
            "Curve CRV": "0xD533a949740bb3306d119CC777fa900bA034cd52",
            "Wormhole Core": "0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B",
            "LayerZero Endpoint": "0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675",
            "Synthetix SNX": "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F",
            # Bridge-specific targets (Ronin-style patterns)
            "Polygon Bridge": "0x8484Ef722627bf18ca5Ae6BcF031c23E6e922B30",
            "Arbitrum Bridge": "0x72Ce9c846789fdB6fC1f34aC4AD25Dd9ef7031ef",
            "Optimism Bridge": "0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1"
        }
        self.targets = targets if targets is not None else default_targets
        
        # Dangerous function selectors
        self.dangerous_selectors = [
            "0xa9059cbb",  # transfer(address,uint256)
            "0x095ea7b3",  # approve(address,uint256)
            "0xac9650d8",  # multicall(bytes[])
            "0xb61d27f6",  # execute(address,uint256,bytes)
            "0x1cff79cd",  # execTransaction(...)
        ]
        
        # Proxy storage slots (EIP-1967)
        self.proxy_slots = [
            "0x360894a13ba1a3210667c828492db98dca3e2076cc5df30dafc8b948a4f811f2",
            "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaab12e85bc0e50b6b6b9eade",
            "0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c5c84b9c0b5d2dcc0b18e74c0"
        ]

        # Governance/bridge risk function selectors (4-byte) to look for in bytecode
        self.gov_bridge_selectors = {
            "grantRole(bytes32,address)": "0x2f2ff15d",
            "setRoleAdmin(bytes32,bytes32)": "0xa547a06e",
            "transferOwnership(address)": "0xf2fde38b",
            "upgradeTo(address)": "0x3659cfe6",
            "upgradeToAndCall(address,bytes)": "0x4f1ef286",
            "mint(address,uint256)": "0x40c10f19",
            "mint(uint256)": "0x18160ddd",
            "burn(uint256)": "0x42966c68",
            "burnFrom(address,uint256)": "0x79cc6790",
            "finalizeInbound(bytes)": "0x1f1c7c70",
            "pause()": "0x8456cb59",
            "unpause()": "0x3f4ba83a"
        }

    def scan_delegatecall_vulnerabilities(self, contract_address: str) -> List[Vulnerability]:
        """Detect Bybit-style delegatecall exploits"""
        vulnerabilities = []
        
        try:
            # Get contract bytecode
            bytecode = self.web3.eth.get_code(contract_address)
            bytecode_hex = bytecode.hex()
            
            # Dangerous patterns in bytecode
            dangerous_patterns = [
                "f4",  # DELEGATECALL opcode
                "f1",  # CALL opcode with dynamic target
                "ff",  # SELFDESTRUCT opcode
            ]
            
            for pattern in dangerous_patterns:
                if pattern in bytecode_hex:
                    severity = "CRITICAL" if pattern == "f4" else "HIGH"
                    vulnerabilities.append(Vulnerability(
                        severity=severity,
                        type="delegatecall_risk",
                        contract=contract_address,
                        description=f"Contract contains {pattern} opcode pattern",
                        details={
                            "opcode": pattern,
                            "pattern_count": bytecode_hex.count(pattern),
                            "risk_factor": "Potential for arbitrary code execution"
                        }
                    ))
            
            # Check for multicall patterns
            if "multicall" in bytecode_hex or "batchcall" in bytecode_hex:
                vulnerabilities.append(Vulnerability(
                    severity="HIGH",
                    type="multicall_risk",
                    contract=contract_address,
                    description="Contract implements multicall functionality",
                    details={
                        "risk": "Batch transaction execution may hide malicious calls",
                        "recommendation": "Verify multicall implementation security"
                    }
                ))
                
        except Exception as e:
            print(f"Error scanning {contract_address}: {e}")
            
        return vulnerabilities

    def detect_upgrade_vulnerabilities(self, contract_address: str) -> List[Vulnerability]:
        """Scan for upgradeable contract vulnerabilities"""
        vulnerabilities = []
        
        try:
            for slot in self.proxy_slots:
                implementation = self.web3.eth.get_storage_at(contract_address, slot)
                
                if implementation != b'\x00' * 32:
                    # Found proxy implementation
                    impl_address = "0x" + implementation[-20:].hex()
                    
                    if impl_address != "0x" + "00" * 20:
                        vulnerabilities.append(Vulnerability(
                            severity="CRITICAL",
                            type="proxy_upgrade_risk",
                            contract=contract_address,
                            description="Contract is upgradeable via proxy pattern",
                            details={
                                "proxy_slot": slot,
                                "implementation": impl_address,
                                "risk": "Admin can upgrade to malicious implementation",
                                "recommendation": "Verify upgrade controls and timelock"
                            }
                        ))
                        
        except Exception as e:
            print(f"Error checking proxy patterns for {contract_address}: {e}")
            
        return vulnerabilities

    def scan_governance_bridge_risks(self, contract_address: str) -> List[Vulnerability]:
        """Heuristic scan for governance/bridge risk by checking for critical function selectors in bytecode.
        This is ABI-less and approximate, but highlights contracts exposing sensitive flows.
        """
        vulnerabilities = []
        try:
            bytecode = self.web3.eth.get_code(contract_address)
            bytecode_hex = bytecode.hex()

            matched = []
            for sig, selector in self.gov_bridge_selectors.items():
                if selector[2:] in bytecode_hex:
                    matched.append(sig)

            if matched:
                vulnerabilities.append(Vulnerability(
                    severity="HIGH",
                    type="governance_bridge_surface",
                    contract=contract_address,
                    description="Contract bytecode contains sensitive governance/bridge function signatures",
                    details={
                        "matched_signatures": matched,
                        "recommendation": "Verify access control, timelocks, and rate limits for these functions"
                    }
                ))

        except Exception as e:
            print(f"Error scanning governance/bridge risks for {contract_address}: {e}")

        return vulnerabilities

    def scan_multisig_security(self, contract_address: str) -> List[Vulnerability]:
        """Analyze multisig contract security"""
        vulnerabilities = []
        
        try:
            # Gnosis Safe ABI for common functions
            threshold_sig = "0x9a9a5593"  # getThreshold()
            owners_sig = "0xa0e67e2b"     # getOwners()
            
            # Try to get threshold
            try:
                threshold_data = self.web3.eth.call({
                    'to': contract_address,
                    'data': threshold_sig
                })
                threshold = int.from_bytes(threshold_data, byteorder='big')
                
                if threshold == 1:
                    vulnerabilities.append(Vulnerability(
                        severity="CRITICAL",
                        type="single_point_failure",
                        contract=contract_address,
                        description="Multisig has 1-of-N threshold",
                        details={
                            "threshold": threshold,
                            "risk": "Single owner can execute any transaction",
                            "recommendation": "Increase threshold to at least 2"
                        }
                    ))
                    
            except:
                pass  # Not a standard multisig
                
            # Try to get owners count
            try:
                owners_data = self.web3.eth.call({
                    'to': contract_address,
                    'data': owners_sig
                })
                # Parse dynamic array return
                if len(owners_data) >= 64:
                    owner_count = int.from_bytes(owners_data[32:64], byteorder='big')
                    
                    if owner_count < 3:
                        vulnerabilities.append(Vulnerability(
                            severity="HIGH",
                            type="insufficient_decentralization",
                            contract=contract_address,
                            description=f"Multisig has only {owner_count} owners",
                            details={
                                "owner_count": owner_count,
                                "risk": "Insufficient decentralization for critical operations",
                                "recommendation": "Add more diverse owners"
                            }
                        ))
                        
            except:
                pass  # Could not determine owner count
                
        except Exception as e:
            print(f"Error analyzing multisig {contract_address}: {e}")
            
        return vulnerabilities

    def analyze_transaction_patterns(self, contract_address: str, blocks_to_scan: int = 100) -> List[Vulnerability]:
        """Analyze recent transaction patterns for suspicious activity"""
        vulnerabilities = []
        
        try:
            latest_block = self.web3.eth.block_number
            start_block = latest_block - blocks_to_scan
            
            suspicious_patterns = []
            
            for block_num in range(start_block, latest_block + 1):
                try:
                    block = self.web3.eth.get_block(block_num, full_transactions=True)
                    
                    for tx in block['transactions']:
                        if tx['to'] and tx['to'].lower() == contract_address.lower():
                            # Check for suspicious patterns
                            if tx['input'] and len(tx['input']) > 10:
                                function_selector = tx['input'][:10]
                                
                                if function_selector in self.dangerous_selectors:
                                    suspicious_patterns.append({
                                        'tx_hash': tx['hash'].hex(),
                                        'block': block_num,
                                        'function_selector': function_selector,
                                        'value': tx['value'],
                                        'gas_used': tx['gas']
                                    })
                                    
                except:
                    continue  # Skip blocks that can't be fetched
                    
            if suspicious_patterns:
                vulnerabilities.append(Vulnerability(
                    severity="MEDIUM",
                    type="suspicious_transaction_pattern",
                    contract=contract_address,
                    description=f"Found {len(suspicious_patterns)} suspicious transactions",
                    details={
                        "pattern_count": len(suspicious_patterns),
                        "recent_transactions": suspicious_patterns[-5:],  # Last 5
                        "recommendation": "Manual review of transaction patterns"
                    }
                ))
                
        except Exception as e:
            print(f"Error analyzing transaction patterns for {contract_address}: {e}")
            
        return vulnerabilities

    def scan_supply_chain_risks(self) -> List[Vulnerability]:
        """Scan for supply chain vulnerabilities in wallet software"""
        vulnerabilities = []
        
        # High-risk NPM packages used by wallets
        risky_packages = [
            {
                'name': 'web3',
                'risk': 'Key extraction through modified web3 calls',
                'impact': 'CRITICAL'
            },
            {
                'name': 'ethers',
                'risk': 'Transaction manipulation in signing process',
                'impact': 'CRITICAL'  
            },
            {
                'name': '@metamask/eth-sig-util',
                'risk': 'Signature verification bypass',
                'impact': 'HIGH'
            },
            {
                'name': 'walletconnect',
                'risk': 'Session hijacking and message interception',
                'impact': 'HIGH'
            }
        ]
        
        for package in risky_packages:
            vulnerabilities.append(Vulnerability(
                severity=package['impact'],
                type="supply_chain_risk",
                contract="N/A",
                description=f"Supply chain risk in {package['name']} package",
                details={
                    "package": package['name'],
                    "risk_vector": package['risk'],
                    "recommendation": "Monitor package updates and verify integrity"
                }
            ))
            
        return vulnerabilities

    def generate_report(self, vulnerabilities: List[Vulnerability]) -> str:
        """Generate a comprehensive vulnerability report"""
        if not vulnerabilities:
            return "No vulnerabilities detected in current scan."
            
        report = []
        report.append("=" * 80)
        report.append("BYBIT-STYLE VULNERABILITY SCAN REPORT")
        report.append("=" * 80)
        report.append(f"Scan Time: {time.strftime('%Y-%m-%d %H:%M:%S UTC')}")
        report.append(f"Total Vulnerabilities Found: {len(vulnerabilities)}")
        report.append("")
        
        # Group by severity
        critical = [v for v in vulnerabilities if v.severity == "CRITICAL"]
        high = [v for v in vulnerabilities if v.severity == "HIGH"]
        medium = [v for v in vulnerabilities if v.severity == "MEDIUM"]
        
        for severity, vulns in [("CRITICAL", critical), ("HIGH", high), ("MEDIUM", medium)]:
            if vulns:
                report.append(f"{severity} SEVERITY ({len(vulns)} found)")
                report.append("-" * 40)
                
                for vuln in vulns:
                    report.append(f"Type: {vuln.type}")
                    report.append(f"Contract: {vuln.contract}")
                    report.append(f"Description: {vuln.description}")
                    
                    if vuln.details:
                        report.append("Details:")
                        for key, value in vuln.details.items():
                            report.append(f"  {key}: {value}")
                    
                    report.append("")
                    
        report.append("=" * 80)
        report.append("RECOMMENDATIONS")
        report.append("=" * 80)
        
        if critical:
            report.append("⚠️  IMMEDIATE ACTION REQUIRED for CRITICAL vulnerabilities")
            report.append("   - Stop all contract interactions")
            report.append("   - Contact protocol security team")
            report.append("   - Prepare incident response")
            report.append("")
            
        if high:
            report.append("🔥 HIGH priority vulnerabilities require prompt attention")
            report.append("   - Review and validate findings")
            report.append("   - Implement fixes within 24-48 hours") 
            report.append("   - Monitor for exploitation attempts")
            report.append("")
            
        if medium:
            report.append("⚡ MEDIUM priority vulnerabilities should be addressed")
            report.append("   - Schedule fixes in next development cycle")
            report.append("   - Document findings for future reference")
            report.append("")
            
        return "\n".join(report)

    async def run_comprehensive_scan(self) -> None:
        """Run a comprehensive vulnerability scan across all targets"""
        print("🚀 Starting Bybit-Style Vulnerability Scan...")
        print(f"📊 Scanning {len(self.targets)} targets")
        print()
        
        all_vulnerabilities = []
        
        # Scan supply chain risks first
        print("🔍 Scanning supply chain risks...")
        supply_chain_vulns = self.scan_supply_chain_risks()
        all_vulnerabilities.extend(supply_chain_vulns)
        
        # Scan each target contract
        for name, address in self.targets.items():
            print(f"🎯 Scanning {name} ({address})")
            
            # Delegatecall vulnerabilities
            delegatecall_vulns = self.scan_delegatecall_vulnerabilities(address)
            all_vulnerabilities.extend(delegatecall_vulns)
            
            # Upgrade mechanism vulnerabilities  
            upgrade_vulns = self.detect_upgrade_vulnerabilities(address)
            all_vulnerabilities.extend(upgrade_vulns)
            
            # Multisig security analysis
            multisig_vulns = self.scan_multisig_security(address)
            all_vulnerabilities.extend(multisig_vulns)
            
            # Transaction pattern analysis
            pattern_vulns = self.analyze_transaction_patterns(address)
            all_vulnerabilities.extend(pattern_vulns)

            # Governance/bridge surface analysis
            gov_bridge_vulns = self.scan_governance_bridge_risks(address)
            all_vulnerabilities.extend(gov_bridge_vulns)
            
            await asyncio.sleep(0.1)  # Rate limiting
            
        # Generate and display report
        report = self.generate_report(all_vulnerabilities)
        print(report)
        
        # Save report to file
        timestamp = int(time.time())
        filename = f"vulnerability_report_{timestamp}.txt"
        with open(filename, 'w') as f:
            f.write(report)
            
        print(f"📝 Report saved to: {filename}")
        
        # Return critical vulnerabilities for immediate action
        critical_vulns = [v for v in all_vulnerabilities if v.severity == "CRITICAL"]
        if critical_vulns:
            print(f"🚨 {len(critical_vulns)} CRITICAL vulnerabilities require immediate attention!")
            return critical_vulns
            
        return all_vulnerabilities

def main():
    """Main execution function"""
    parser = argparse.ArgumentParser(description="Bybit-Style Vulnerability Scanner")
    parser.add_argument("--rpc", help="RPC URL override (e.g., Sonic or Ethereum)")
    parser.add_argument("--targets", help="Path to JSON mapping of name->address to scan")
    args = parser.parse_args()

    # Load RPC URL (prefer CLI, then env SONIC_RPC_URL, then ETH)
    rpc_url = args.rpc or os.getenv('SONIC_RPC_URL') or os.getenv('ETH_RPC_URL', 'https://eth-mainnet.alchemyapi.io/v2/demo')

    if 'demo' in rpc_url:
        print("⚠️  Using demo RPC URL. Set SONIC_RPC_URL or ETH_RPC_URL for production use.")
        print()

    # Load targets if provided
    targets = None
    if args.targets:
        try:
            with open(args.targets, 'r') as f:
                targets = json.load(f)
        except Exception as e:
            print(f"Warning: failed to load targets file {args.targets}: {e}")

    # Initialize scanner
    scanner = VulnerabilityScanner(rpc_url, targets)

    # Run comprehensive scan
    try:
        asyncio.run(scanner.run_comprehensive_scan())
    except KeyboardInterrupt:
        print("\n⏹️  Scan interrupted by user")
    except Exception as e:
        print(f"❌ Scan failed: {e}")

if __name__ == "__main__":
    main()