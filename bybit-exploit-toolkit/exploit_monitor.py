#!/usr/bin/env python3
"""
Real-time Exploit Monitor
Monitors high-value DeFi protocols for Bybit-style exploits in real-time
"""

import asyncio
import json
import time
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from web3 import Web3
from web3.exceptions import BlockNotFound, TransactionNotFound
import requests
import os

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('exploit_monitor.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class SuspiciousTransaction:
    """Data structure for suspicious transactions"""
    tx_hash: str
    block_number: int
    timestamp: int
    contract_address: str
    from_address: str
    to_address: str
    value: int
    gas_used: int
    function_selector: str
    risk_score: int
    alert_type: str
    details: Dict[str, Any]

class ExploitMonitor:
    """Real-time monitor for Bybit-style exploits"""
    
    def __init__(self, rpc_url: str, webhook_url: Optional[str] = None, ioc_file: Optional[str] = None):
        self.web3 = Web3(Web3.HTTPProvider(rpc_url))
        self.webhook_url = webhook_url
        self.ioc_watchlist: Dict[str, Any] = {}
        if ioc_file and os.path.exists(ioc_file):
            try:
                with open(ioc_file, 'r') as f:
                    self.ioc_watchlist = json.load(f)
                logger.info(f"Loaded IOC watchlist: {len(self.ioc_watchlist.get('addresses', []))} addresses")
            except Exception as e:
                logger.error(f"Failed to load IOC file {ioc_file}: {e}")
        
        # High-value monitoring targets
        self.monitored_contracts = {
            "Compound Finance": {
                "address": "0xc00e94Cb662C3520282E6f5717214004A7f26888",
                "tvl": 2_100_000_000,
                "risk_level": "CRITICAL"
            },
            "Aave Protocol": {
                "address": "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
                "tvl": 1_800_000_000,
                "risk_level": "CRITICAL"
            },
            "Wormhole Bridge": {
                "address": "0x98f3c9e6E3fAce36bAAd05FE09d375Ef1464288B",
                "tvl": 1_500_000_000,
                "risk_level": "CRITICAL"
            },
            "Curve Finance": {
                "address": "0xD533a949740bb3306d119CC777fa900bA034cd52",
                "tvl": 800_000_000,
                "risk_level": "HIGH"
            },
            "LayerZero": {
                "address": "0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675",
                "tvl": 800_000_000,
                "risk_level": "HIGH"
            },
            "Synthetix": {
                "address": "0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F",
                "tvl": 600_000_000,
                "risk_level": "HIGH"
            }
        }
        
        # Suspicious function selectors
        self.dangerous_selectors = {
            "0xa9059cbb": "transfer",
            "0x095ea7b3": "approve", 
            "0xac9650d8": "multicall",
            "0xb61d27f6": "execute",
            "0x1cff79cd": "execTransaction",
            "0x6a761202": "execTransactionFromModule",
            "0x468721a7": "execTransactionFromModuleReturnData",
            "0xf4e19547": "delegatecall_proxy",
            "0x5c60da1b": "implementation",
            "0x3659cfe6": "upgradeTo"
        }
        
        # Large value thresholds (in Wei)
        self.value_thresholds = {
            "CRITICAL": 100 * 10**18,  # 100 ETH
            "HIGH": 50 * 10**18,       # 50 ETH
            "MEDIUM": 10 * 10**18      # 10 ETH
        }
        
        self.last_processed_block = None
        self.suspicious_transactions = []

    def calculate_risk_score(self, tx: Dict[str, Any], contract_info: Dict[str, Any]) -> int:
        """Calculate risk score for a transaction (0-100)"""
        risk_score = 0
        
        # Base score from contract TVL
        tvl = contract_info.get('tvl', 0)
        if tvl > 1_000_000_000:
            risk_score += 30
        elif tvl > 500_000_000:
            risk_score += 20
        else:
            risk_score += 10
            
        # Function selector risk
        function_selector = tx.get('input', '')[:10] if tx.get('input') else ''
        if function_selector in self.dangerous_selectors:
            risk_score += 25
            
        # Transaction value risk
        value = tx.get('value', 0)
        if value >= self.value_thresholds['CRITICAL']:
            risk_score += 35
        elif value >= self.value_thresholds['HIGH']:
            risk_score += 25
        elif value >= self.value_thresholds['MEDIUM']:
            risk_score += 15
            
        # Gas usage patterns (unusually high gas)
        gas = tx.get('gas', 0)
        if gas > 500000:
            risk_score += 10
            
        # Time-based risk (transactions outside normal hours)
        current_hour = datetime.now().hour
        if current_hour < 6 or current_hour > 22:  # Outside business hours
            risk_score += 5
            
        return min(risk_score, 100)

    def analyze_transaction_data(self, tx: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze transaction input data for suspicious patterns"""
        analysis = {
            'contains_delegatecall': False,
            'contains_selfdestruct': False,
            'has_complex_multicall': False,
            'suspicious_patterns': []
        }
        
        input_data = tx.get('input', '')
        if len(input_data) < 10:
            return analysis
            
        # Check for delegatecall patterns in input data
        if 'f4' in input_data.lower():  # DELEGATECALL opcode
            analysis['contains_delegatecall'] = True
            analysis['suspicious_patterns'].append('delegatecall_detected')
            
        # Check for selfdestruct patterns
        if 'ff' in input_data.lower():  # SELFDESTRUCT opcode
            analysis['contains_selfdestruct'] = True
            analysis['suspicious_patterns'].append('selfdestruct_detected')
            
        # Check for complex multicall (multiple function calls)
        if 'multicall' in input_data.lower() and len(input_data) > 1000:
            analysis['has_complex_multicall'] = True
            analysis['suspicious_patterns'].append('complex_multicall')
            
        # Check for upgrade-related calls
        upgrade_patterns = ['upgrade', 'implement', 'proxy']
        for pattern in upgrade_patterns:
            if pattern in input_data.lower():
                analysis['suspicious_patterns'].append(f'upgrade_pattern_{pattern}')
                
        return analysis

    async def send_alert(self, suspicious_tx: SuspiciousTransaction) -> None:
        """Send alert via webhook or logging"""
        alert_data = {
            'timestamp': datetime.now().isoformat(),
            'alert_type': suspicious_tx.alert_type,
            'risk_score': suspicious_tx.risk_score,
            'transaction': asdict(suspicious_tx),
            'message': f"üö® SUSPICIOUS TRANSACTION DETECTED - Risk Score: {suspicious_tx.risk_score}/100"
        }
        
        # Log the alert
        logger.warning(f"ALERT: {suspicious_tx.alert_type} - TX: {suspicious_tx.tx_hash} - Risk: {suspicious_tx.risk_score}/100")
        
        # Send webhook if configured
        if self.webhook_url:
            try:
                response = requests.post(
                    self.webhook_url,
                    json=alert_data,
                    timeout=10
                )
                if response.status_code == 200:
                    logger.info(f"Alert sent successfully for TX: {suspicious_tx.tx_hash}")
                else:
                    logger.error(f"Failed to send alert: {response.status_code}")
            except Exception as e:
                logger.error(f"Error sending webhook alert: {e}")

    async def process_transaction(self, tx: Dict[str, Any], block_info: Dict[str, Any]) -> Optional[SuspiciousTransaction]:
        """Process a single transaction for suspicious activity"""
        if not tx.get('to'):
            return None
            
        to_address = tx['to'].lower()
        
        # IOC check: if from/to in watchlist, raise immediate alert
        if self.ioc_watchlist:
            addr_set = set([a.lower() for a in self.ioc_watchlist.get('addresses', [])])
            if tx['from'].lower() in addr_set or to_address in addr_set:
                suspicious_tx = SuspiciousTransaction(
                    tx_hash=tx['hash'].hex(),
                    block_number=block_info['number'],
                    timestamp=block_info['timestamp'],
                    contract_address=to_address,
                    from_address=tx['from'],
                    to_address=to_address,
                    value=tx.get('value', 0),
                    gas_used=tx.get('gas', 0),
                    function_selector=tx.get('input', '')[:10] if tx.get('input') else '',
                    risk_score=95,
                    alert_type="IOC_MATCH",
                    details={
                        'reason': 'Address matched IOC watchlist',
                        'watchlist_tag': self.ioc_watchlist.get('tag', 'attacker'),
                        'chain': self.ioc_watchlist.get('chain', 'unknown')
                    }
                )
                return suspicious_tx

        # Check if transaction is to a monitored contract
        monitored_contract = None
        for name, info in self.monitored_contracts.items():
            if info['address'].lower() == to_address:
                monitored_contract = (name, info)
                break
                
        if not monitored_contract:
            return None
            
        contract_name, contract_info = monitored_contract
        
        # Calculate risk score
        risk_score = self.calculate_risk_score(tx, contract_info)
        
        # Only alert on medium+ risk transactions
        if risk_score < 50:
            return None
            
        # Analyze transaction data
        data_analysis = self.analyze_transaction_data(tx)
        
        # Determine alert type
        alert_type = "UNKNOWN"
        if data_analysis['contains_delegatecall']:
            alert_type = "DELEGATECALL_EXPLOIT"
        elif data_analysis['contains_selfdestruct']:
            alert_type = "SELFDESTRUCT_ATTACK"
        elif data_analysis['has_complex_multicall']:
            alert_type = "COMPLEX_MULTICALL"
        elif tx.get('value', 0) >= self.value_thresholds['CRITICAL']:
            alert_type = "LARGE_VALUE_TRANSFER"
        else:
            alert_type = "SUSPICIOUS_ACTIVITY"
            
        # Create suspicious transaction record
        suspicious_tx = SuspiciousTransaction(
            tx_hash=tx['hash'].hex(),
            block_number=block_info['number'],
            timestamp=block_info['timestamp'],
            contract_address=to_address,
            from_address=tx['from'],
            to_address=to_address,
            value=tx.get('value', 0),
            gas_used=tx.get('gas', 0),
            function_selector=tx.get('input', '')[:10] if tx.get('input') else '',
            risk_score=risk_score,
            alert_type=alert_type,
            details={
                'contract_name': contract_name,
                'contract_tvl': contract_info['tvl'],
                'data_analysis': data_analysis,
                'function_name': self.dangerous_selectors.get(tx.get('input', '')[:10], 'unknown')
            }
        )
        
        return suspicious_tx

    async def process_block(self, block_number: int) -> List[SuspiciousTransaction]:
        """Process all transactions in a block"""
        try:
            block = self.web3.eth.get_block(block_number, full_transactions=True)
            suspicious_txs = []
            
            for tx in block['transactions']:
                suspicious_tx = await self.process_transaction(tx, block)
                if suspicious_tx:
                    suspicious_txs.append(suspicious_tx)
                    await self.send_alert(suspicious_tx)
                    
            return suspicious_txs
            
        except BlockNotFound:
            logger.warning(f"Block {block_number} not found")
            return []
        except Exception as e:
            logger.error(f"Error processing block {block_number}: {e}")
            return []

    async def monitor_latest_blocks(self) -> None:
        """Monitor the latest blocks for suspicious activity"""
        logger.info("üîç Starting real-time block monitoring...")
        
        while True:
            try:
                latest_block = self.web3.eth.block_number
                
                if self.last_processed_block is None:
                    self.last_processed_block = latest_block - 1
                    
                # Process any missed blocks
                blocks_to_process = list(range(self.last_processed_block + 1, latest_block + 1))
                
                for block_number in blocks_to_process:
                    logger.info(f"üì¶ Processing block {block_number}")
                    suspicious_txs = await self.process_block(block_number)
                    
                    if suspicious_txs:
                        self.suspicious_transactions.extend(suspicious_txs)
                        logger.warning(f"üö® Found {len(suspicious_txs)} suspicious transactions in block {block_number}")
                        
                    self.last_processed_block = block_number
                    
                # Wait for next block
                await asyncio.sleep(12)  # Ethereum block time ~12 seconds
                
            except KeyboardInterrupt:
                logger.info("‚èπÔ∏è  Monitoring stopped by user")
                break
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(5)  # Wait before retrying

    async def scan_recent_history(self, blocks_back: int = 100) -> None:
        """Scan recent transaction history for missed exploits"""
        logger.info(f"üìö Scanning last {blocks_back} blocks for suspicious activity...")
        
        latest_block = self.web3.eth.block_number
        start_block = latest_block - blocks_back
        
        total_suspicious = 0
        
        for block_number in range(start_block, latest_block + 1):
            suspicious_txs = await self.process_block(block_number)
            if suspicious_txs:
                total_suspicious += len(suspicious_txs)
                self.suspicious_transactions.extend(suspicious_txs)
                
            if block_number % 10 == 0:
                logger.info(f"üìä Processed {block_number - start_block + 1}/{blocks_back} blocks")
                
        logger.info(f"‚úÖ Historical scan complete. Found {total_suspicious} suspicious transactions.")

    def generate_summary_report(self) -> str:
        """Generate a summary report of monitoring activity"""
        if not self.suspicious_transactions:
            return "No suspicious activity detected during monitoring period."
            
        report = []
        report.append("=" * 80)
        report.append("REAL-TIME EXPLOIT MONITORING SUMMARY")
        report.append("=" * 80)
        report.append(f"Monitoring Period: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Suspicious Transactions: {len(self.suspicious_transactions)}")
        report.append("")
        
        # Group by alert type
        alert_types = {}
        for tx in self.suspicious_transactions:
            alert_type = tx.alert_type
            if alert_type not in alert_types:
                alert_types[alert_type] = []
            alert_types[alert_type].append(tx)
            
        for alert_type, txs in alert_types.items():
            report.append(f"{alert_type}: {len(txs)} transactions")
            
            # Show highest risk transactions
            sorted_txs = sorted(txs, key=lambda x: x.risk_score, reverse=True)
            for tx in sorted_txs[:3]:  # Top 3
                report.append(f"  üö® Risk {tx.risk_score}/100 - {tx.tx_hash}")
                report.append(f"     Contract: {tx.details.get('contract_name', 'Unknown')}")
                report.append(f"     Value: {tx.value / 10**18:.2f} ETH")
                report.append("")
                
        report.append("=" * 80)
        
        return "\n".join(report)

    async def run_monitor(self, scan_history: bool = True, history_blocks: int = 100) -> None:
        """Run the complete monitoring system"""
        logger.info("üöÄ Starting Bybit-Style Exploit Monitor")
        logger.info(f"üìä Monitoring {len(self.monitored_contracts)} high-value contracts")
        
        # Scan recent history first
        if scan_history:
            await self.scan_recent_history(history_blocks)
            
        # Start real-time monitoring
        try:
            await self.monitor_latest_blocks()
        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è  Monitoring stopped by user")
        finally:
            # Generate final report
            report = self.generate_summary_report()
            logger.info("\n" + report)
            
            # Save report to file
            timestamp = int(time.time())
            filename = f"monitoring_report_{timestamp}.txt"
            with open(filename, 'w') as f:
                f.write(report)
            logger.info(f"üìù Final report saved to: {filename}")

def main():
    """Main execution function"""
    # Load configuration from environment and args
    import argparse
    parser = argparse.ArgumentParser(description="Real-time Exploit Monitor")
    parser.add_argument("--rpc", help="RPC URL override")
    parser.add_argument("--iocs", help="Path to IOC watchlist JSON file")
    args = parser.parse_args()

    rpc_url = args.rpc or os.getenv('SONIC_RPC_URL') or os.getenv('ETH_RPC_URL', 'https://eth-mainnet.alchemyapi.io/v2/demo')
    webhook_url = os.getenv('WEBHOOK_URL')  # Optional Discord/Slack webhook
    
    if 'demo' in rpc_url:
        logger.warning("‚ö†Ô∏è  Using demo RPC URL. Set ETH_RPC_URL environment variable for production use.")
        
    # Initialize monitor
    monitor = ExploitMonitor(rpc_url, webhook_url, ioc_file=args.iocs)
    
    # Run monitoring
    try:
        asyncio.run(monitor.run_monitor())
    except KeyboardInterrupt:
        logger.info("‚èπÔ∏è  Monitor stopped by user")
    except Exception as e:
        logger.error(f"‚ùå Monitor failed: {e}")

if __name__ == "__main__":
    main()